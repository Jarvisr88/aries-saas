namespace DevExpress.Xpf.Grid.Native
{
    using DevExpress.Mvvm.Native;
    using DevExpress.Xpf.Core.ConditionalFormatting.Native;
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Runtime.CompilerServices;
    using System.Windows;
    using System.Windows.Media.Animation;

    internal class AnimationController
    {
        private Queue<AnimationControllerQueueItem> animationQueue = new Queue<AnimationControllerQueueItem>();
        private IAnimationConnector activeConnectorCore;
        private IList<ITimelineWrapper> earlyDeactivationAnimations;
        private IStoryboardWrapper activeStoryboardWrapper;
        private IAnimationWrapperFactory wrapperFactory;

        public AnimationController()
        {
            Func<AnimationElement> func1 = <>c.<>9__16_0;
            if (<>c.<>9__16_0 == null)
            {
                Func<AnimationElement> local1 = <>c.<>9__16_0;
                func1 = <>c.<>9__16_0 = () => new AnimationElement();
            }
            this.AnimationElementFactory = func1;
            this.earlyDeactivationAnimations = new List<ITimelineWrapper>();
        }

        private bool CanContinueFromActiveAnimationState()
        {
            if (this.activeStoryboardWrapper == null)
            {
                return true;
            }
            Func<Timeline, bool> predicate = <>c.<>9__25_0;
            if (<>c.<>9__25_0 == null)
            {
                Func<Timeline, bool> local1 = <>c.<>9__25_0;
                predicate = <>c.<>9__25_0 = x => AutogeneratedTimelineHelper.GetHideRatio(x) == 0.0;
            }
            return this.activeStoryboardWrapper.GetChildren().Any<Timeline>(predicate);
        }

        private void ClearAnimationQueue()
        {
            this.animationQueue.Clear();
        }

        public virtual void Complete()
        {
            this.ResetActiveStoryboard();
            this.ActiveConnector = null;
            this.StartAnimationFromQueue();
        }

        private IStoryboardWrapper CreateStoryboardWrapper(Storyboard storyboard) => 
            this.WrapperFactory.CreateStoryboardWrapper(storyboard);

        protected internal virtual IAnimationWrapperFactory CreateWrapperFactory() => 
            new AnimationWrapperFactory();

        public void Flush()
        {
            this.ClearAnimationQueue();
            this.Complete();
        }

        private MaskedAnimationTimeline GetMaskedAnimationTimeline(IList<AnimationTimeline> animations)
        {
            AnimationMask none = AnimationMask.None;
            Stack<AnimationTimeline> stack = new Stack<AnimationTimeline>();
            Duration? nullable = null;
            bool flag = false;
            for (int i = animations.Count - 1; i > -1; i--)
            {
                AnimationTimeline timeline2 = animations[i];
                AnimationMask subMask = GetSubMask(timeline2);
                if ((subMask == AnimationMask.None) || !none.HasFlag(subMask))
                {
                    if (!flag)
                    {
                        Duration duration = timeline2.Duration;
                        if ((nullable != null) && (nullable.Value != duration))
                        {
                            flag = true;
                        }
                        nullable = new Duration?(duration);
                    }
                    stack.Push(timeline2);
                    none |= subMask;
                }
            }
            MaskedAnimationTimeline timeline = new MaskedAnimationTimeline();
            while (stack.Count > 0)
            {
                timeline.TimeLines.Add(stack.Pop());
            }
            timeline.Mask = none;
            timeline.HasEarlyAnimations = flag;
            return timeline;
        }

        private static AnimationMask GetSubMask(Timeline timeline) => 
            (timeline != null) ? AnimationPropertyPaths.GetAnimationMask(Storyboard.GetTargetProperty(timeline)) : AnimationMask.None;

        private void OnEarlyDeactivation(object sender, EventArgs e)
        {
            ITimelineWrapper wrapper = sender as ITimelineWrapper;
            if (wrapper != null)
            {
                Func<IAnimationConnector, AnimationElement> evaluator = <>c.<>9__23_0;
                if (<>c.<>9__23_0 == null)
                {
                    Func<IAnimationConnector, AnimationElement> local1 = <>c.<>9__23_0;
                    evaluator = <>c.<>9__23_0 = x => x.ConnectedElement;
                }
                AnimationElement element = this.ActiveConnector.With<IAnimationConnector, AnimationElement>(evaluator);
                if (element != null)
                {
                    AnimationMask subMask = GetSubMask(wrapper.Timeline);
                    if (subMask != AnimationMask.None)
                    {
                        element.Mask &= ~subMask;
                    }
                }
            }
        }

        private void OnStoryboardCompleted(object sender, EventArgs e)
        {
            this.Complete();
        }

        private void ResetActiveStoryboard()
        {
            if (this.activeStoryboardWrapper != null)
            {
                this.activeStoryboardWrapper.Stop();
                this.activeStoryboardWrapper.Completed -= new EventHandler(this.OnStoryboardCompleted);
                this.activeStoryboardWrapper = null;
                this.UpdateEarlyDeactivationAnimations(null);
            }
        }

        public void Start(IList<IList<AnimationTimeline>> animations, IAnimationConnector connector)
        {
            if (animations != null)
            {
                this.ClearAnimationQueue();
                foreach (IList<AnimationTimeline> list in animations)
                {
                    AnimationControllerQueueItem item = new AnimationControllerQueueItem();
                    item.TimeLines = list;
                    item.Connector = connector;
                    this.animationQueue.Enqueue(item);
                }
                if (this.CanContinueFromActiveAnimationState())
                {
                    this.StartAnimationFromQueue();
                }
                else
                {
                    this.Complete();
                }
            }
        }

        public virtual void Start(IList<AnimationTimeline> animations, IAnimationConnector connector)
        {
            if (animations != null)
            {
                Storyboard storyboard = new Storyboard();
                MaskedAnimationTimeline maskedTimeline = this.GetMaskedAnimationTimeline(animations);
                foreach (AnimationTimeline timeline in maskedTimeline.TimeLines)
                {
                    storyboard.Children.Add(timeline);
                }
                AnimationElement element = this.AnimationElementFactory();
                element.Do<AnimationElement>(e => e.Mask = maskedTimeline.Mask);
                Storyboard.SetTarget(storyboard, element);
                this.ActiveConnector = connector;
                this.ActiveConnector.Do<IAnimationConnector>(x => x.ConnectedElement = element);
                this.ResetActiveStoryboard();
                this.UpdateEarlyDeactivationAnimations(maskedTimeline.EarlyAnimation);
                this.activeStoryboardWrapper = this.CreateStoryboardWrapper(storyboard);
                this.activeStoryboardWrapper.Completed += new EventHandler(this.OnStoryboardCompleted);
                this.activeStoryboardWrapper.Begin();
            }
        }

        private void StartAnimationFromQueue()
        {
            if (this.animationQueue.Count > 0)
            {
                AnimationControllerQueueItem item = this.animationQueue.Dequeue();
                this.Start(item.TimeLines, item.Connector);
            }
        }

        private void StopConnectorAnimation(bool shouldRestoreConditionalAppearance)
        {
            if (this.activeConnectorCore != null)
            {
                this.activeConnectorCore.Disconnect();
                if (shouldRestoreConditionalAppearance)
                {
                    this.activeConnectorCore.UpdateAppearance();
                }
                if (this.animationQueue.Count == 0)
                {
                    this.activeConnectorCore.OnAnimationSeriesEnd();
                }
            }
        }

        private void UpdateEarlyDeactivationAnimations(IList<AnimationTimeline> timeLines)
        {
            foreach (ITimelineWrapper wrapper in this.earlyDeactivationAnimations)
            {
                wrapper.Deactivated -= new EventHandler(this.OnEarlyDeactivation);
            }
            this.earlyDeactivationAnimations.Clear();
            if (timeLines != null)
            {
                foreach (AnimationTimeline timeline in timeLines)
                {
                    ITimelineWrapper item = this.WrapperFactory.CreateTimelineWrapper(timeline);
                    item.Deactivated += new EventHandler(this.OnEarlyDeactivation);
                    this.earlyDeactivationAnimations.Add(item);
                }
            }
        }

        public Func<AnimationElement> AnimationElementFactory { get; set; }

        private IAnimationConnector ActiveConnector
        {
            get => 
                this.activeConnectorCore;
            set
            {
                if (!ReferenceEquals(this.activeConnectorCore, value))
                {
                    this.StopConnectorAnimation(ReferenceEquals(value, null));
                    this.activeConnectorCore = value;
                }
            }
        }

        private IAnimationWrapperFactory WrapperFactory
        {
            get
            {
                this.wrapperFactory ??= this.CreateWrapperFactory();
                return this.wrapperFactory;
            }
        }

        [Serializable, CompilerGenerated]
        private sealed class <>c
        {
            public static readonly AnimationController.<>c <>9 = new AnimationController.<>c();
            public static Func<AnimationElement> <>9__16_0;
            public static Func<IAnimationConnector, AnimationElement> <>9__23_0;
            public static Func<Timeline, bool> <>9__25_0;

            internal AnimationElement <.ctor>b__16_0() => 
                new AnimationElement();

            internal bool <CanContinueFromActiveAnimationState>b__25_0(Timeline x) => 
                AutogeneratedTimelineHelper.GetHideRatio(x) == 0.0;

            internal AnimationElement <OnEarlyDeactivation>b__23_0(IAnimationConnector x) => 
                x.ConnectedElement;
        }

        private class AnimationControllerQueueItem : AnimationController.AnimationTimelineContainerBase
        {
            public IAnimationConnector Connector { get; set; }
        }

        private abstract class AnimationTimelineContainerBase
        {
            public AnimationTimelineContainerBase()
            {
                this.TimeLines = new List<AnimationTimeline>();
            }

            public IList<AnimationTimeline> TimeLines { get; set; }
        }

        private class MaskedAnimationTimeline : AnimationController.AnimationTimelineContainerBase
        {
            public AnimationMask Mask { get; set; }

            public bool HasEarlyAnimations { get; set; }

            public IList<AnimationTimeline> EarlyAnimation =>
                this.HasEarlyAnimations ? base.TimeLines : null;
        }
    }
}

