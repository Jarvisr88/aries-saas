namespace DevExpress.Mvvm.DataAnnotations
{
    using DevExpress.Mvvm;
    using DevExpress.Mvvm.Native;
    using System;
    using System.ComponentModel;
    using System.Linq.Expressions;
    using System.Runtime.InteropServices;

    public abstract class PropertyMetadataBuilderGeneric<T, TProperty, TBuilder> : PropertyMetadataBuilderBase<T, TProperty, TBuilder> where TBuilder: PropertyMetadataBuilderGeneric<T, TProperty, TBuilder>
    {
        internal PropertyMetadataBuilderGeneric(MemberMetadataStorage storage, ClassMetadataBuilder<T> parent) : base(storage, parent)
        {
        }

        public TBuilder AutoGenerated() => 
            base.AutoGeneratedCore();

        public TBuilder ConvertTo(Type type) => 
            base.AddOrReplaceAttribute<ConvertToAttribute>(new ConvertToAttribute(type));

        public TBuilder DefaultEditor(object templateKey) => 
            base.DefaultEditorCore(templateKey);

        public TBuilder DependsOn(params Expression<Func<T, object>>[] propertyExpression)
        {
            foreach (Expression<Func<T, object>> expression in propertyExpression)
            {
                string name = ExpressionHelper.GetArgumentPropertyStrict<T, object>(expression).Name;
                base.AddAttribute(new DependsOnPropertiesAttribute(name));
            }
            return (TBuilder) this;
        }

        public TBuilder Description(string description) => 
            base.DescriptionCore(description);

        public TBuilder DisplayFormatString(string dataFormatString, bool applyDisplayFormatInEditMode = false) => 
            base.DisplayFormatStringCore(dataFormatString, applyDisplayFormatInEditMode);

        public TBuilder DisplayName(string name) => 
            base.DisplayNameCore(name);

        public TBuilder DisplayShortName(string shortName) => 
            base.DisplayShortNameCore(shortName);

        public TBuilder DoesNotReturnService() => 
            base.AddOrReplaceAttribute<ServicePropertyAttribute>(new ServicePropertyAttribute(false));

        public TBuilder DoNotConvertEmptyStringToNull() => 
            base.DoNotConvertEmptyStringToNullCore();

        public TBuilder DoNotMakeBindable() => 
            base.AddOrReplaceAttribute<BindablePropertyAttribute>(new BindablePropertyAttribute(false));

        public TBuilder DoNotScaffold() => 
            base.DoNotScaffoldCore();

        public TBuilder DoNotScaffoldDetailCollection() => 
            base.DoNotScaffoldDetailCollectionCore();

        public MetadataBuilder<T> EndProperty() => 
            (MetadataBuilder<T>) base.parent;

        public TBuilder GridEditor(object templateKey) => 
            base.GridEditorCore(templateKey);

        public TBuilder Hidden(bool hidden = true) => 
            base.HiddenCore(hidden);

        public TBuilder Initializer<TValue>(Func<TValue> createDelegate, string name = null) => 
            base.InitializerCore<TValue>(createDelegate, name);

        public TBuilder LayoutControlEditor(object templateKey) => 
            base.LayoutControlEditorCore(templateKey);

        public TBuilder LocatedAt(int position, PropertyLocation propertyLocation = 0) => 
            base.LocatedAtCore(position, propertyLocation);

        public TBuilder MakeBindable() => 
            base.AddOrReplaceAttribute<BindablePropertyAttribute>(new BindablePropertyAttribute());

        [Obsolete("Use the MatchesInstanceRule(Func<TProperty, T, bool> isValidFunction, Func<string> errorMessageAccessor = null) method instead."), Browsable(false), EditorBrowsable(EditorBrowsableState.Never)]
        public TBuilder MatchesInstanceRule(Func<T, bool> isValidFunction, Func<string> errorMessageAccessor = null) => 
            base.MatchesInstanceRuleCore(isValidFunction, errorMessageAccessor);

        public TBuilder MatchesInstanceRule(Func<TProperty, T, bool> isValidFunction, Func<string> errorMessageAccessor = null) => 
            this.MatchesInstanceRuleCore(isValidFunction, (errorMessageAccessor == null) ? null : (x, y) => errorMessageAccessor());

        public TBuilder MatchesInstanceRule(Func<TProperty, T, bool> isValidFunction, Func<TProperty, T, string> errorMessageAccessor) => 
            base.MatchesInstanceRuleCore(isValidFunction, errorMessageAccessor);

        public TBuilder MatchesRegularExpression(string pattern, Func<string> errorMessageAccessor = null) => 
            base.MatchesRegularExpressionCore(pattern, GetErrorMessageAccessor(errorMessageAccessor));

        public TBuilder MatchesRegularExpression(string pattern, Func<TProperty, string> errorMessageAccessor) => 
            base.MatchesRegularExpressionCore(pattern, errorMessageAccessor);

        public TBuilder MatchesRule(Func<TProperty, bool> isValidFunction, Func<string> errorMessageAccessor = null) => 
            base.MatchesRuleCore(isValidFunction, GetErrorMessageAccessor(errorMessageAccessor));

        public TBuilder MatchesRule(Func<TProperty, bool> isValidFunction, Func<TProperty, string> errorMessageAccessor) => 
            base.MatchesRuleCore(isValidFunction, errorMessageAccessor);

        public TBuilder MaxLength(int maxLength, Func<string> errorMessageAccessor = null) => 
            base.MaxLengthCore(maxLength, GetErrorMessageAccessor(errorMessageAccessor));

        public TBuilder MaxLength(int maxLength, Func<TProperty, string> errorMessageAccessor) => 
            base.MaxLengthCore(maxLength, errorMessageAccessor);

        public TBuilder MinLength(int minLength, Func<string> errorMessageAccessor = null) => 
            base.MinLengthCore(minLength, GetErrorMessageAccessor(errorMessageAccessor));

        public TBuilder MinLength(int minLength, Func<TProperty, string> errorMessageAccessor) => 
            base.MinLengthCore(minLength, errorMessageAccessor);

        public TBuilder NotAutoGenerated() => 
            base.NotAutoGeneratedCore();

        public TBuilder NotEditable() => 
            base.NotEditableCore();

        public TBuilder NullDisplayText(string nullDisplayText) => 
            base.NullDisplayTextCore(nullDisplayText);

        public TBuilder OnPropertyChangedCall(Expression<Action<T>> onPropertyChangedExpression) => 
            base.AddOrModifyAttribute<BindablePropertyAttribute>(delegate (BindablePropertyAttribute x) {
                x.OnPropertyChangedMethod = ExpressionHelper.GetArgumentMethodStrict<T>(onPropertyChangedExpression);
            });

        public TBuilder OnPropertyChangingCall(Expression<Action<T>> onPropertyChangingExpression) => 
            base.AddOrModifyAttribute<BindablePropertyAttribute>(delegate (BindablePropertyAttribute x) {
                x.OnPropertyChangingMethod = ExpressionHelper.GetArgumentMethodStrict<T>(onPropertyChangingExpression);
            });

        public TBuilder PropertyGridEditor(object templateKey) => 
            base.PropertyGridEditorCore(templateKey);

        public TBuilder ReadOnly() => 
            base.ReadOnlyCore();

        public TBuilder Required(Func<string> errorMessageAccessor) => 
            base.RequiredCore(errorMessageAccessor);

        public TBuilder Required(bool allowEmptyStrings = false, Func<string> errorMessageAccessor = null) => 
            base.RequiredCore(allowEmptyStrings, errorMessageAccessor);

        public TBuilder ReturnsService(ServiceSearchMode searchMode = 0) => 
            this.ReturnsService(null, searchMode);

        public TBuilder ReturnsService(string key, ServiceSearchMode searchMode = 0)
        {
            ServicePropertyAttribute attribute = new ServicePropertyAttribute();
            attribute.SearchMode = searchMode;
            attribute.Key = key;
            return base.AddOrReplaceAttribute<ServicePropertyAttribute>(attribute);
        }

        public TypeConverterBuilder<T, TProperty, TBuilder> TypeConverter() => 
            base.TypeConverterCore();

        public TBuilder TypeConverter<TConverter>() where TConverter: System.ComponentModel.TypeConverter, new() => 
            base.TypeConverterCore<TConverter>();
    }
}

